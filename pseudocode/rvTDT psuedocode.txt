############################

Functions

############################

get.rvTDT.results<-function(filepath.vcf, filepath.annovar, window.size=25, window.type = “M”){

filepath.vcf<-
vcf<-readVcf(filepath.vcf)
pos<-start(rowRanges(vcf)) 
geno<-trio::get.geno.matrix
rm(vcf)

evs<-.getEVS(filepath.annovar,pos)
ped<-.get.rvTDT.PED(geno)
results<-.run.rvTDT(window.sz,window.type, evs, ped)

}

########################################################

# Helper Functions - get.rvTDT.results

########################################################

.getEVS<-function(filepath.annovar,vcf.pos){

  annovar<-read.table(filepath.annovar,sep="\t",header=TRUE, quote ="")

  evs<-annovar %>%
    filter(!is.na(Afalt_1000g2015aug_eur)) %>%
    filter(TotalDepth>20) %>%
    mutate(geno0 = (1-Afalt_1000g2015aug_eur)^2) %>%
    mutate(geno1 = (1-Afalt_1000g2015aug_eur)*Afalt_1000g2015aug_eur)  %>%
    mutate(geno2 = (Afalt_1000g2015aug_eur)^2)  %>%
    dplyr::select("StartPosition",
                  "geno2",
                  "geno1",
                  "geno0",
                  "TotalDepth"
    ) %>%
select(StartPosition %in% pos)

return(evs)

  #evs.filtered<-evs.raw[evs.raw$StartPosition %in% pos,]
 
}

EVS - coontain the control information from evs,
4 columns: rowname:
varaint’s ID: 
chr_pos_ref_alt;
col1: number of samples have genotype 2
col2: number of samples have genotype 1;
col3: number of samples have genotype 0
col4: mean coverage at this locus

###################################################

.get.rvTDT.ped<-function(geno){
  geno<-readRDS(filepath.geno)
  dim(geno)  
  nrows<-nrow(geno)
  f.index<-seq(1,nrows,by=3)
  m.index<-seq(2,nrows,by=3)
  c.index<-seq(3,nrows,by=3) 
  rvTDT.ped<-rbind(geno[c.index,], geno[m.index,],geno[f.index,])
  rvTDT.ped
    
}


PED - 

contain the genotype information for all samples

assume m families and n snps, 3m * n matrix

each column represents a variant, coded by 0/1/2 (number of alternative alleles)

each row represents a sample, the first m rows are for child

the second m rows are for mother

the last m rows are for father

########################################################

.run.rvTDT<-function(window.sz,window.type, evs, ped){

        #return rvTDT results as df
        if (window.size==0){
                n.windows<-1
                window.size<-nrow(map)
        } else {
                n.windows<- max(n.snps - window.size + 1,1)
        }

        results.df<-as.data.frame(matrix(data=NA,nrow=n.windows, ncol=8))
        colnames(results.df)<-c(
                "X.gene", "CMC.Analytical","BRV.Haplo","CMC.Haplo","VT.BRV.Haplo","VT.CMC.Haplo","WSS.Haplo",
                "mid.window.pos"
        )

        #TODO: Get rid of for loop and use a list instead
        #Make this into a function, and use apply instead?
        #Indexing is very slow for data frames

        for (i in (1:n.windows)){
                input.files<-.getrvTDTFilesForWindow(ped,evs,window.type,window.size,i)
                curr.window.result<-.calculatervTDTOnWindow(input.filepaths)
                results[i,]<-c(curr.window.result, mid.position)
        }

        return(results.df)

}

########################################################

# Helper Functions - .run.rvTDT

########################################################

.getInputFilesForWindow<-function(ped, eve, window.type, window.size, i){

        n.snps<- nrow(map)

        start.index<-i
        end.index<-min(i+window.size-1,n.snps)
        mid.position<- floor(start.index + (end.index - start.index)/2)

        sm.evs<-evs[start.index:end.index,]
        sm.ped<-ped[start.index:end.index,]

}

############################

.runRV_TDTOnWindow<-function(input.filepaths, param){

        .calculateRV_TDTOnWindow(input.filepaths, param)
        results<-.extract.results(input.filepaths)
        .clean.up.rv_tdt(input.filepaths)
        return(results)

}